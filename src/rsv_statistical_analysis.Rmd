---
title: "Statistical analysis: Multivalent Antigen Display on Nanoparticles Elicits Diverse and Broad B cell Responses"
author: "Rodrigo Arcoverde Cerveira and Sebastian Ols"
date: '`r format(Sys.Date(), "%Y-%m-%d")`'
output: 
 html_document:
    toc: true
    depth: 2
    toc_float: true
    number_sections: true
 github_document:
    preview_html: false
knit: (function(inputFile, encoding) {
          rmarkdown::render(inputFile,
                            encoding = encoding, 
                            output_file = paste0(
                              xfun::sans_ext(inputFile), '.html'))})
---

```{r setup, include=FALSE}
knitr::opts_knit$set(
  echo = TRUE,
  root.dir = getwd(),
  fig.width = 6, fig.height = 5, fig.align='center',
  warning = FALSE,
  message = FALSE
)
knitr::opts_chunk$set(
  warning = FALSE,
  echo = TRUE,
  message = FALSE
)

result.dir <- paste0("results/", Sys.Date(), "/")

# creates result.dir with date in if not existent
ifelse(isFALSE(dir.exists(paste0("../", result.dir))), dir.create(paste0("../", result.dir), recursive = TRUE), "Result directory for today exists already!")
options(stringsAsFactors = FALSE)
```

# Summary

This `Rmarkdown` file provides a breakdown of a selection of the statistical analyses from the manuscript entitled “Multivalent Antigen Display on Nanoparticles Diversifies B Cell Responses”. It includes mainly the statistical tests run on analyses of plasma antibody specificities and memory B cell clonality.

# Loaded libraries

The main libraries used for statistical analysis are shown here.

```{r librares_2, message=FALSE, results='hide', echo=FALSE}
library(jsonlite)
library(Biostrings)
library(treeio)
library(ggtree)
source("df_to_fasta.R")
library(data.table)
library(vegan)
```

```{r libraries, message=FALSE, results='hide'}
library(tidyr)
library(rstatix)
library(ggpubr)
library(ggplot2)
library(scales)
library(ggprism)
library(dplyr)
library(forcats)
library(kableExtra)
set.seed(123)
```

# Loaded data

The values used for statistical analyses and plotting are loaded here from .csv files or .rds files. The values have been calculated or obtained from other programs or scripts. A description of tThe data sources can be found in each section and the raw data can be found in the accompanying repository.

```{r load_rds, results='hide'}
data_comp <- read.csv("../data/ELISA_comp/2023-03-06_normalized_plasma_compt.csv")
clonotype_rsv <- readRDS("../data/clonotypes/individualized/rsv-specific_clonotypes.rds")

# set color for fill and color aes layers
fill_col_values <- c("20-mer" = "#5F90B0", "10-mer" = "#92CDD5", "1-mer" = "#D896C1", "PostF" = "grey50")
color_values <- c("20-mer" = "#2E6997", "10-mer" = "#469698", "1-mer" = "#BE3C8C", "PostF" = "grey20")
```

```{r hidden_processing, results='hide', echo=FALSE, message=FALSE}
data_comp <- data_comp %>% mutate(group = case_when(group == "NP 100%" ~ "20-mer",
                           group == "NP 50%" ~ "10-mer",
                           group == "Sol" ~ "1-mer",
                           group == "PostF" ~ "PostF"))

clonotype_rsv <- clonotype_rsv %>%
  filter(timepoint != "PV") %>%
  mutate(cdr3_aa_length = nchar(CDR3_aa),
         cdr3_aa = CDR3_aa,
         v_call = V_gene,
         j_call = J_gene,
         d_call = D_gene) 

# load repertoire sequencing reads info
rep_seq_ls <- list.files("../data/processed_data/rep_seq", pattern = "stats.json", recursive = TRUE, full.names = TRUE)
rep_seq_names <- list.files("../data/processed_data/rep_seq", pattern = "stats.json", recursive = TRUE, full.names = FALSE)
names(rep_seq_ls) <- sub("_st","",gsub("/","_",substr(rep_seq_names, 1,10)))

# load mAbs data
lor_mabs <- read.csv("../data/specificity/LOR_single-cells_characterized.csv")
mabs_lors <- read.csv("../data/single_cell/sc_summary_filtered.csv")

# load competition ELISA data
# edited the raw values to have the max value as the reference competition for ADI, MPE8, 101F, D25
data_comp_auc <- read.csv("../data/ELISA_comp/2023-04-28_LOR_norm-dAUC.csv", header = T, row.names = 1, encoding="UTF-8") %>%
  replace(is.na(.), 0) %>%
  mutate(specificity = factor(specificity, levels = c("PreF", "PreF/PostF", "PostF", "w.b.")),
         epitope = factor(epitope, levels = c("Ø","V", "IV","III", "II","I", "foldon", "UK-Pre","UK-DP","PostF", "WB")))

# load light chains information clonotyped
clono_light_chains <- read.table("../data/clonotypes/light_chain_assigned_clonotypes.tsv", sep = "\t", header = TRUE) 
```

# Plasma antibody specificity profiling

The polyclonal antibody specificities in the plasma of immunized animals were assessed using a competition ELISA with reference monoclonal antibodies (mAbs). This analysis was performed for antigenic sites on both the preF and postF conformations of RSV-F. To assess specificity skewing from repeated immunizations, analysis was performed at boost 1 (4 weeks post second immunization) and boost 2 (2 weeks post third immunization). Statistical analyses performed here correct for the multiple comparisons made across groups, time points, and antigenic sites.

## Competition for epitopes on preF (Fig. 3K)

Competition with five (5) reference mAbs targeting distinct epitopes on preF were analyzed. Each of the three groups was compared against each other at each of two time points using a two-tailed Wilcoxon rank sum test (a.k.a. Mann-Whitney U test). This means a total of six (6) comparisons were made for each of the reference mAbs. Statistical analysis was not performed for one mAb at the boost 1 time point as most data points were below the limit of detection. Thus, a total of 24 comparisons were made.To correct for these multiple comparisons, the false discovery rate correction by Benjamini & Hochberg (1995) was applied (alpha = 0.05). Also, the p-values and adjusted p-values for each comparison are listed in the table that follows.

```{r competition_bars_pref}
# Imported ELISA competition data is identified by reference mAb and corresponding antigenic site on preF or postF. Time point of analysis is also identified
data_comp_longer <- data_comp %>%
  pivot_longer(cols = 2:9, names_to = "mAb", values_to = "ELISA_competition") %>%
  mutate(epitopes = plyr::mapvalues(mAb, 
                                    from = c("D25.PreF", "MPE8.PreF", "ADI.PreF", "Pali.PreF", "X101F.PreF",
                                             "ADI.PostF", "X101F.PostF", "Pali.PostF"), 
                                    to = c("Ø", "III", "I", "II", "IV",
                                           "I", "IV", "II")),
         epitopes = factor(epitopes, levels = c("Ø", "III", "IV", "II", "I")),
         conformation = factor(case_when(grepl("PostF", mAb) ~ "PostF",
                                  grepl("PreF", mAb) ~ "PreF"), levels = c("PreF", "PostF")),
        timepoint_group = paste(timepoints, group, sep = "_"),
        timepoint_group_epitope = paste(timepoints, group, epitopes, sep = "_")) 

# In Figure 3, the postF group has not been analyzed and hence its values are filtered out from the analysis performed here
data_comp_longer_noPostF <- data_comp_longer %>%
  filter(group != "PostF")

# Each group is compared against each other within each time point (B1 or B2)
my_comparisons_sites <- list(c("B1_1-mer", "B1_20-mer"),
                       c("B1_1-mer", "B1_10-mer"),
                       c("B1_10-mer", "B1_20-mer"),
                       c("B2_1-mer", "B2_20-mer"),
                       c("B2_1-mer", "B2_10-mer"),
                       c("B2_10-mer", "B2_20-mer")
                       )
# The comparison of groups by time point is done for each antigenic site analyzed
my_comparisons_1 <- lapply(my_comparisons_sites, paste0, "_I")
my_comparisons_2 <- lapply(my_comparisons_sites, paste0, "_II")
my_comparisons_3 <- lapply(my_comparisons_sites, paste0, "_III")
my_comparisons_4 <- lapply(my_comparisons_sites, paste0, "_IV")
my_comparisons_5 <- lapply(my_comparisons_sites, paste0, "_Ø")

# The comparisons are compiled into a list for preF
# The statistical comparisons for antigenic site I in preF at Boost 1 is filtered out from analysis as most values were below the limit of detection
my_comparisons_preF <- c(my_comparisons_1[4:6], my_comparisons_2, my_comparisons_3, my_comparisons_4, my_comparisons_5)
  
# The two-tailed Wilcoxon rank sum test with an FDR correction is run for the 24 comparisons specified earlier
stat.test <- data_comp_longer_noPostF %>%
  filter(conformation == "PreF") %>%
  wilcox_test(formula = ELISA_competition ~ timepoint_group_epitope, 
              paired = FALSE, 
              p.adjust.method = "fdr", 
              comparisons = my_comparisons_preF)

# The statistical analyses are printed as a table (shown below)
stat.test %>%
  select(-c(.y.)) %>%
  kable %>%
  kable_styling("striped") %>% 
 scroll_box(height = "200px")

# The data is plotted as a dot plot with corresponding adjusted p-values reaching significance (adj. p < 0.05)
data_comp_longer_noPostF %>%
  filter(conformation == "PreF") %>%
  ggplot(aes(x = timepoint_group,
            y = ELISA_competition,
            color = group,
            fill = group)) +
  geom_point(size = 2, shape = 21) +
  scale_fill_manual(values = fill_col_values) +
  scale_color_manual(values = color_values) +
  ggprism::theme_prism(base_fontface = "plain", border = TRUE, base_line_size = .5) +
  scale_y_log10() +
  stat_summary(fun.y = mean, 
               geom = "crossbar",
               color = "black") +
  geom_hline(yintercept = 10, linetype = "dashed") +
  labs(title = "PreF Antigenic Sites", y = "50% Competition Titer", x = "") +
  theme(axis.ticks = element_line(size = .5),
        legend.background = element_blank(),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, size = 7)) +
  facet_wrap(~epitopes, nrow = 1) 

```

## Competition for epitopes on postF (Fig. 3L)

Competition with three (3) reference mAbs targeting distinct epitopes on postF were analyzed. Each of the three groups was compared against each other at each of two time points using a two-tailed Wilcoxon rank sum test (a.k.a. Mann-Whitney U test or a non-parametric t-test). This means a total of six (6) comparisons were made for each of the reference mAbs. Thus, a total of 18 comparisons were made. To correct for these multiple comparisons, the false discovery rate correction by Benjamini & Hochberg (1995) was applied (alpha = 0.05). Also, the p-values and adjusted p-values for each comparison are listed in the table that follows.

```{r competition_bars_postf}
# The comparison of groups by time point is done for each antigenic site on postF (i.e., sites I, II, IV)
my_comparisons_postF <- c(my_comparisons_1, my_comparisons_2, my_comparisons_4)

# The two-tailed Wilcoxon rank sum test with an FDR correction is run for the 18 comparisons specified earlier
stat.test <- data_comp_longer_noPostF %>%
  filter(conformation == "PostF") %>%
  wilcox_test(formula = ELISA_competition ~ timepoint_group_epitope, 
              paired = FALSE, 
              p.adjust.method = "fdr", 
              comparisons = my_comparisons_postF)

# The statistical analyses are printed as a table (shown below)
stat.test %>%
  select(-c(.y.)) %>%
  kable %>%
  kable_styling("striped") %>% 
 scroll_box(height = "200px")

# The data is plotted as a dot plot with corresponding adjusted p-values reaching significance (adj. p < 0.05)
data_comp_longer_noPostF %>%
  filter(conformation == "PostF") %>%
  ggplot(aes(x = timepoint_group,
            y = ELISA_competition,
            color = group,
            fill = group)) +
  geom_point(size = 2, shape = 21) +
  scale_fill_manual(values = fill_col_values) +
  scale_color_manual(values = color_values) +
  ggprism::theme_prism(base_fontface = "plain", border = TRUE, base_line_size = .5) +
  scale_y_log10() +
  stat_summary(fun.y = mean, 
               geom = "crossbar",
               color = "black") +
  geom_hline(yintercept = 10, linetype = "dashed") +
  labs(title = "PostF Antigenic Sites", y = "50% Competition Titer", x = "") +
  theme(axis.ticks = element_line(size = .5),
        legend.background = element_blank(),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, size = 7)) +
  facet_wrap(~epitopes, nrow = 1) 

```


```{r shm_avg_dbs_processing, echo=FALSE, results='hide'}

ls <- list.files("../data/clonotypes", recursive = T, full.names = T)
ls <- ls[grepl("rsv", ls) & grepl("individualized|nestor-rm", ls) ]
names(ls) <- basename(dirname(ls))
rds_merge <- lapply(ls, readRDS)
rds_merge <- rbindlist(rds_merge, idcol = TRUE, fill = TRUE)
rds_merge <- rds_merge %>%
  select(.id, specificity_group, sc_clone_grp, grp, new_name, ID_timepoint, V_SHM, V_errors, CDR3_aa, cdr3_aa, V_gene, J_gene, v_call, j_call) %>%
  mutate(
    Timepoint = factor(gsub(".*_", "", ID_timepoint), levels = c("PV", "B1", "B2", "Single-cell")),
    ID = gsub("_.*", "", ID_timepoint),
    database = plyr::mapvalues(.id,
      from = c("nestor-rm", "individualized"),
      to = c("KIMDB", "Individualized")
    ),
    database = factor(database, levels = c("KIMDB", "Individualized")),
    Group = plyr::mapvalues(
      ID, c(
        "E11", "E16", "E17", "E23", "E24",
        "E12", "E14", "E18", "E21"
      ),
      c(
        "20-mer", "20-mer", "20-mer", "20-mer", "20-mer",
        "1-mer", "1-mer", "1-mer", "1-mer"
      )
    ),
    cdr3_aa_length = ifelse(is.na(CDR3_aa), nchar(cdr3_aa), nchar(CDR3_aa)),
    v_call = ifelse(is.na(v_call), V_gene, v_call),
    j_call = ifelse(is.na(j_call), J_gene, j_call)
  ) %>%
  group_by(.id, ID_timepoint) %>%
  distinct(new_name, .keep_all = TRUE) %>%
  ungroup() %>%
  filter(database %in% c("KIMDB", "Individualized"))

```


```{r plot_clonotypes, echo = FALSE, results='hide'}

rds_summary <- rds_merge %>%
  group_by(database, ID_timepoint, grp) %>%
  summarise(
    ID = first(ID), Timepoint = first(Timepoint), Group = first(Group),
    clonal_size = n(),
    database,
    sc_clone_grp = first(sc_clone_grp),
    V_errors = mean(V_errors),
    specificity_group = first(specificity_group),
    cdr3_aa_length = mean(cdr3_aa_length),
    v_call = first(v_call),
    j_call = first(j_call)
  ) %>%
  ungroup() %>%
  group_by(database, ID_timepoint) %>%
  mutate(clonal_size_rank = dense_rank(dplyr::desc(clonal_size))) %>%
  ungroup() %>%
  distinct()

rds_summary_noPV <- rds_summary %>%
  filter(Timepoint != "PV", Timepoint != "Single-cell")

rds_summary_save <- rds_summary %>%
  filter(Timepoint %in% c("Single-cell", "B1","B2"),
         database == "Individualized") %>%
  group_by(ID_timepoint) %>%
  summarise(mean_clonal_size = mean(clonal_size),
            median_clonal_size = median(clonal_size),
            geom_clonal_size = exp(mean(log(clonal_size))),
            unique_clones = sum(clonal_size == 1),
            total_clones_detected = n(),
            percentage_unique_clones = round(unique_clones/total_clones_detected*100, digits = 2)) 

rds_summary_save %>%
  kable %>%
  kable_styling("striped") %>% 
 scroll_box(height = "200px")

write.csv(rds_summary_save, 
          paste0("../", result.dir, "clone_size_mean_median.csv"),row.names = FALSE)

```


```{r indv_lors_plot, echo=FALSE, results='hide'}
rds_indiv <- rds_summary %>%
  filter(
    database == "Individualized",
    Timepoint != "Single-cell",
    Timepoint != "PV"
  ) %>%
  mutate(
    LOR = ifelse(grepl(pattern = paste0(lor_mabs$well_ID, collapse = "|"), x = sc_clone_grp), "cloned", "not_cloned"),
    LOR = factor(LOR, levels = c("cloned", "not_cloned"), ordered = TRUE)
  )
rds_indiv$Timepoint <- droplevels(rds_indiv$Timepoint)
all <- rds_indiv %>%
  tidyr::expand(ID, Timepoint, grp) %>%
  filter(Timepoint != "Single-cell")

rds_indiv <- rds_indiv %>%
  right_join(all) %>%
  mutate(
    ID_timepoint = paste(ID, Timepoint, sep = "_"),
    database = "individualized",
    clonal_size = ifelse(is.na(clonal_size), 0, clonal_size)
  ) %>%
  arrange(grp, ID_timepoint) %>%
  tidyr::fill(LOR, Group, sc_clone_grp)

```

# Memory B cell profiling 

To assess if epitope-focusing of circulating memory B cells in 20-mer animals relative to 1-mer animals was the result of an oligoclonal or polyclonal expansion we studied the clonotype diversity with different metrics. We combined single-cell BCR sequences of known specificity (~400 B cells per animal) with longitudinal bulk IgG repertoire sequencing datasets. This yielded a total of ~190,000 RSV-F-specific BCR sequences at boost 1 and boost 2 time points with a clonal relationship. Different metrics of diversity were calculated from these clonotypes and assigned a specificity based on the antigen-specific sorting. Statistical analyses performed here correct for the multiple comparisons made across groups, time points, and specificities.

## Count unique IGHV-IGHJ pairs (Fig. 5J)

The diversity of responding B cells was here assessed by gene usage and counting of unique IGHV-IGHJ pairs. The two groups were compared against each other at each of two time points for three different specificities: Total F, preF, or preF/postF (DP). For this, a two-tailed Wilcoxon rank sum test (a.k.a. Mann-Whitney U test) was employed. This means a total of six (6) comparisons were made. To correct for these multiple comparisons, the false discovery rate correction by Benjamini & Hochberg (1995) was applied (alpha = 0.05). Also, the p-values and adjusted p-values for each comparison are listed in the table that follows. 

```{r count_uniq_processing, results='hide', echo=FALSE, message=FALSE}
rds_summary_noPV <- rds_summary %>%
  filter(database == "Individualized", Timepoint != "Single-cell", Timepoint != "PV") %>%
  rbind(., within(., specificity_group <- "Total")) %>%
  filter(specificity_group != "PostF") %>%
  mutate(Group_specificity = paste(specificity_group, Timepoint, Group, sep = "_"),
         Group_specificity = factor(Group_specificity, levels = c("Total_B1_20-mer", "Total_B1_1-mer", "Total_B2_20-mer", "Total_B2_1-mer", "PreF_B1_20-mer", "PreF_B1_1-mer", "PreF_B2_20-mer", "PreF_B2_1-mer", "DP_B1_20-mer", "DP_B1_1-mer", "DP_B2_20-mer", "DP_B2_1-mer"))) %>%
  group_by(ID_timepoint, specificity_group, Group_specificity, Group) %>%
  mutate(v_j_calls = paste(v_call,j_call, sep = "_")) %>%
  distinct(v_j_calls) %>%
  summarise(unique_v_j = n()) %>%
  ungroup()

rds_summary_noPV %>% write.csv(paste0("../", result.dir,"unique_HV_HJ_pairing-data.csv"), row.names = F)
```

```{r vj_count_and_statistic}
# The two vaccine groups are compared by specificity at each sequenced timepoint
my_comparisons <- list(c("Total_B1_20-mer", "Total_B1_1-mer"),
                       c("Total_B2_20-mer", "Total_B2_1-mer"),
                       c("PreF_B1_20-mer", "PreF_B1_1-mer"),
                       c("PreF_B2_20-mer", "PreF_B2_1-mer"),
                       c("DP_B1_20-mer", "DP_B1_1-mer"),
                       c("DP_B2_20-mer", "DP_B2_1-mer"))

# The two-tailed Wilcoxon rank sum test with an FDR correction is run for the 6 comparisons specified earlier 
stat.test <- rds_summary_noPV %>%
              wilcox_test(formula = unique_v_j ~ Group_specificity, 
                          comparisons = my_comparisons, 
                          p.adjust.method = "fdr", 
                          paired = FALSE) %>%
  add_xy_position()

# The statistical analyses are printed as a table (shown below) 
stat.test %>%
  select(-c(.y., y.position,	groups,	xmin,	xmax)) %>%
  kable %>%
  kable_styling("striped") %>% 
 scroll_box(height = "200px")

# The data is plotted as a dot plot with corresponding adjusted p-values  
rds_summary_noPV %>%
  ggpubr::ggdotplot(x = "Group_specificity", y = "unique_v_j", 
                    fill = "Group", 
                    color = "Group",
                    group = "Group_specificity", 
                    legend = "none", size = 1) +
  geom_vline(xintercept = seq(2.5,12,2), linetype = "dotted") +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 200)) +
  scale_x_discrete(expand = c(0, 0)) +
  scale_fill_manual(values = fill_col_values) +
  scale_color_manual(values = color_values) +
  labs(y = "HV and HJ unique pairs\n(Count)", x = "") +
  stat_summary(fun.y = mean, 
               geom = "crossbar") +
  stat_pvalue_manual(stat.test, label = "p.adj", y.position = 150) +
  ggprism::theme_prism(base_fontface = "plain", border = T, base_line_size = .5, axis_text_angle = 45) +
  theme(axis.ticks = element_line(size = .5),
        legend.position = "none")

```

## Clonotype richness Chao1 (Fig. 5K)

The species richness (Chao1) used in this section was calculated using the vegan R package. The samples were first subsampled 100 times for each animal at each timepoint and specificity and then the species richness was estimated. The means of the 100x replicates were used for plotting. As before, the two groups were compared against each other at each of two time points for three different specificities: Total F, preF, or preF/postF (DP). For this, a two-tailed Wilcoxon rank sum test (a.k.a. Mann-Whitney U test) was employed. This means a total of six (6) comparisons were made. To correct for these multiple comparisons, the false discovery rate correction by Benjamini & Hochberg (1995) was applied (alpha = 0.05). Also, the p-values and adjusted p-values for each comparison are listed in the table that follows.

```{r rsv_per_timepoint_specificity, echo = FALSE, results='hide'}
# add column for loop of ID, timepoint and specificity
clonotype_rsv <- clonotype_rsv %>%
  mutate(ID_timepoint_spec = paste0(ID_timepoint, "_", specificity_group))

# create empty lists for loop
filtered_animal_rsv <- list()
clonotype_summary_rsv <- list()

# loop to create summary and full clonotype files for saving and/or following analysis
for (animals in unique(clonotype_rsv$ID_timepoint_spec)) {
  # save full clonotype files
  filtered_animal_rsv[[animals]] <- clonotype_rsv %>%
    filter(ID_timepoint_spec == animals) %>%
    as.data.frame()
 # write.csv(filtered_animal_rsv[[animals]], paste0("../", result.dir, animals, "_clonotype_full.csv"), row.names = FALSE)

  # save summary files
  clonotype_summary_rsv[[animals]] <- filtered_animal_rsv[[animals]] %>%
    group_by(grp, timepoint, ID, specificity_group, ID_timepoint_spec) %>%
    summarise(clonal_size = n(), first(v_call), first(j_call), first(cdr3_aa)) %>%
    arrange(desc(clonal_size)) %>%
    ungroup()
  #write.csv(clonotype_summary_rsv[[animals]], paste0("../", result.dir, animals, "_rsv_clonotype_summary.csv"), row.names = FALSE)
  }

# doing the same thing but for total, that means not account for specificities (PreF, DP,PostF)
for (animals in unique(clonotype_rsv$ID_timepoint)) {
  # save summary files
  clonotype_summary_rsv[[paste0(animals, "_total")]] <- clonotype_rsv %>%
    filter(ID_timepoint == animals) %>%
    as.data.frame() %>%
    mutate(
      specificity_group = "Total",
      ID_timepoint_spec = paste0(ID_timepoint, "_", specificity_group)
    ) %>%
    group_by(grp, timepoint, ID, specificity_group, ID_timepoint_spec) %>%
    summarise(clonal_size = n(), first(v_call), first(j_call), first(cdr3_aa)) %>%
    arrange(desc(clonal_size)) %>%
    ungroup()
 # write.csv(clonotype_summary_rsv[[animals]], paste0("../", result.dir, animals, "_rsv_clonotype_summary.csv"), row.names = FALSE)
  }


# Save clonotype summary per animal, taking into account ID, timepoint and clonal group
filtered_animal_rsv_summary <- list()

for (animals in unique(clonotype_rsv$ID)) {
  # save summary files
  clonotype_rsv %>%
    filter(ID == animals) %>%
    as.data.frame() %>%
    group_by(grp, timepoint, ID) %>%
    summarise(clonal_size = n(), single_cells = first(sc_clone_grp), v_call = first(v_call), j_call = first(j_call), cdr3_aa = first(cdr3_aa)) %>%
    arrange(desc(clonal_size)) %>%
    ungroup() 
   # write.csv(paste0("../", result.dir, animals, "_rsv_clonotype_summary.csv"), row.names = FALSE)
    }

to_recon_rsv <- data.table::rbindlist(clonotype_summary_rsv) %>%
  select(clonal_size, ID_timepoint_spec) %>%
  group_by(clonal_size, ID_timepoint_spec) %>%
  summarise(size = n()) %>%
  ungroup()


for (i in unique(to_recon_rsv$ID_timepoint_spec)) {
  to_recon_table <- to_recon_rsv %>%
    filter(ID_timepoint_spec == i) %>%
    select(clonal_size, size)

 # fwrite(to_recon_table, file = paste0("../", result.dir, i, "_rsv_file_to_recon.txt"), append = FALSE, sep = "\t", row.names = FALSE, col.names = FALSE)
}
```


```{r generate_chao1_estimates_rsv, echo = FALSE, results='hide'}

rsv_chao <- lapply(clonotype_summary_rsv, function(x) select(x, "clonal_size"))


# subsample and replicate the subsampling 100 times for higher accuracy

chaox100 <- function(x, value_to_subsample) {
  replicate(100, {
    subsample <- vegan::rrarefy(x, value_to_subsample)
    chao <- vegan::estimateR(subsample)
    return(chao)
  })
}

diff_spec_timepoints <- unique(substring(names(clonotype_summary_rsv), 5))

# subsample based on lowest total clonotype size per group
chao_list_results <- list()
for (spec_timepoint in diff_spec_timepoints) {
  print(spec_timepoint)
  rsv_filtered <- rsv_chao[grepl(spec_timepoint, names(rsv_chao))]
  min_to_subsample <- min(unlist(lapply(rsv_filtered, colSums)))
  chao_list_results[[spec_timepoint]] <- lapply(rsv_filtered, chaox100, min_to_subsample)
}

change_names <- function(x) {
  names(x) <- gsub("_.*", "", names(x))
  x
}

# adjusted dataset for plotting
{
  chao_results_df <- purrr::map(chao_list_results, ~ change_names(.x))
  chao_results_df <- rbindlist(chao_results_df, use.names = TRUE, idcol = TRUE, fill = TRUE)
  chao_results_df$algorithm <- rep(c("Obs", "Chao1", "Chao1_se", "ACE", "ACE_se"), nrow(chao_results_df) / 5)
  # save intermediate file
  chao_results_df %>%
    filter(algorithm %in% c("Chao1", "ACE")) %>%
    dplyr::rename(Timepoint_specificity = .id) %>%
    write.csv(paste0("../", result.dir, "rsv_repertoire_diversity.csv"), row.names = FALSE)
  # diversity mean of x100 replicates per animal
  chao_results_df %>%
    filter(algorithm %in% c("Chao1", "ACE")) %>%
    dplyr::rename(Timepoint_specificity = .id) %>%
    group_by(algorithm, Timepoint_specificity) %>%
    summarise_all(.funs = mean) %>%
    write.csv(paste0("../", result.dir, "rsv_repertoire_diversity_mean.csv"), row.names = FALSE)

  chao_results_df <- tidyr::pivot_longer(chao_results_df, cols = 2:(length(chao_results_df) - 1), names_to = c("ID")) %>%
    tidyr::separate(.id, c("Timepoint", "Specificity"), sep = "_") %>%
    mutate(Group = plyr::mapvalues(
      ID, c(
        "E11", "E16", "E17", "E23", "E24",
        "E12", "E14", "E18", "E21"
      ),
      c(
        "20-mer", "20-mer", "20-mer", "20-mer", "20-mer",
        "1-mer", "1-mer", "1-mer", "1-mer"
      )
    ))
}
```

```{r plot_chao1_2, echo=FALSE, message=FALSE}
chao_results_df$Specificity[chao_results_df$Specificity == "total"] <- "Total"

chao_results_df <- chao_results_df %>%
  filter(algorithm != "Chao1_se" & algorithm != "ACE_se") %>%
  filter(algorithm == "Chao1", Timepoint != "PV", Timepoint != "Single-cell",) %>%
  mutate(Group = plyr::mapvalues(
      ID, c(
        "E11", "E16", "E17", "E23", "E24",
        "E12", "E14", "E18", "E21"
      ),
      c(
        "20-mer", "20-mer", "20-mer", "20-mer", "20-mer",
        "1-mer", "1-mer", "1-mer", "1-mer"
      )
    ),
    Group_specificity = paste(Specificity, Timepoint, Group, sep = "_"),
    Group_specificity = factor(Group_specificity, levels = c("Total_B1_20-mer", "Total_B1_1-mer", "Total_B2_20-mer", "Total_B2_1-mer", "PreF_B1_20-mer", "PreF_B1_1-mer", "PreF_B2_20-mer", "PreF_B2_1-mer", "DP_B1_20-mer", "DP_B1_1-mer", "DP_B2_20-mer", "DP_B2_1-mer"))) %>%
  group_by(ID, Group, Timepoint, Specificity, algorithm, Group_specificity) %>%
  summarise(value = mean(value)) %>%
  tidyr::drop_na() %>%
  ungroup()

write.csv(chao_results_df, paste0("../", result.dir, "chao1_results_plot_values.csv"), row.names = FALSE)

```

```{r plot_chao1}

stat.test <- chao_results_df %>%
              wilcox_test(formula = value ~ Group_specificity, 
                          comparisons = my_comparisons, 
                          p.adjust.method = "fdr", 
                          paired = FALSE) %>%
  add_xy_position()

stat.test %>%
  select(-c(.y., y.position,	groups,	xmin,	xmax)) %>%
  kable %>%
  kable_styling("striped") %>% 
 scroll_box(height = "200px")

chao_results_df %>%
  ggpubr::ggdotplot(x = "Group_specificity", y = "value", 
                    fill = "Group", 
                    color = "Group",
                    group = "Group_specificity", 
                    legend = "none", size = 1) +
  geom_vline(xintercept = seq(2.5,12,2), linetype = "dotted") +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 300)) +
  scale_x_discrete(expand = c(0, 0)) +
  scale_fill_manual(values = fill_col_values) +
  scale_color_manual(values = color_values) +
  labs(y = "Species richness\n(Chao1)", x = "") +
  stat_summary(fun.y = mean, 
               geom = "crossbar") +
  stat_pvalue_manual(stat.test, label = "p.adj", y.position = 270) +
  ggprism::theme_prism(base_fontface = "plain", border = T, base_line_size = .5, axis_text_angle = 45) +
  theme(axis.ticks = element_line(size = .5),
        legend.position = "none")

```

## Clonotype richness – Recon (Fig. 5L)

The species richness (Recon) used in this section was calculated using Recon (v2.5) (Kaplinsky & Arnaout, Nat Commmun, 2016) according to default parameters. As before, the two groups were compared against each other at each of two time points for three different specificities: Total F, preF, or preF/postF (DP). For this, a two-tailed Wilcoxon rank sum test (a.k.a. Mann-Whitney U test) was employed. This means a total of six (6) comparisons were made. To correct for these multiple comparisons, the false discovery rate correction by Benjamini & Hochberg (1995) was applied (alpha = 0.05). Also, the p-values and adjusted p-values for each comparison are listed in the table that follows.

```{r recon_diversity_stats}
## The output from Recon was used to perform the statistics, here the data is just processed to have the correct rows and nomenclatures.
recon_res <- read.table("../data/diversity_index/recon/rsv_output_diversity_table.txt", header = TRUE) %>%
  filter(Timepoint != "PV", Timepoint != "Single-cell", Specificity != "PostF") %>%
  mutate(Group = plyr::mapvalues(
      ID, c(
        "E11", "E16", "E17", "E23", "E24",
        "E12", "E14", "E18", "E21"
      ),
      c(
        "20-mer", "20-mer", "20-mer", "20-mer", "20-mer",
        "1-mer", "1-mer", "1-mer", "1-mer"
      )
    ),
   Group_specificity = paste(Specificity, Timepoint, Group, sep = "_")) %>%
  mutate(Group_specificity = factor(Group_specificity, levels = c("Total_B1_20-mer", "Total_B1_1-mer", "Total_B2_20-mer", "Total_B2_1-mer", "PreF_B1_20-mer", "PreF_B1_1-mer", "PreF_B2_20-mer", "PreF_B2_1-mer", "DP_B1_20-mer", "DP_B1_1-mer", "DP_B2_20-mer", "DP_B2_1-mer"))) %>%
  ungroup()

write.csv(recon_res, paste0("../", result.dir, "recon_results_plot_values.csv"), row.names = FALSE)
  
# The two-tailed Wilcoxon rank sum test with an FDR correction is run for the 6 comparisons specified earlier
stat.test <- recon_res %>%
              wilcox_test(formula = est_0.0D ~ Group_specificity, 
                          comparisons = my_comparisons, 
                          p.adjust.method = "fdr", 
                          paired = FALSE) %>%
  add_xy_position()

# The statistical analyses are printed as a table (shown below)
stat.test %>%
  select(-c(.y., y.position,	groups,	xmin,	xmax)) %>%
  kable %>%
  kable_styling("striped") %>% 
 scroll_box(height = "200px")

# The data is plotted as a dot plot with corresponding adjusted p-values
recon_res %>%
  ggpubr::ggdotplot(x = "Group_specificity", y = "est_0.0D", 
                    fill = "Group", 
                    color = "Group",
                    group = "Group_specificity", 
                    legend = "none", size = 1) +
  geom_vline(xintercept = seq(2.5,12,2), linetype = "dotted") +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 300)) +
  scale_x_discrete(expand = c(0, 0)) +
  scale_fill_manual(values = fill_col_values) +
  scale_color_manual(values = color_values) +
  labs(y = "Species richness\n(Recon)", x = "") +
  stat_summary(fun.y = mean, 
               geom = "crossbar") +
  stat_pvalue_manual(stat.test, label = "p.adj", y.position = 270) +
  ggprism::theme_prism(base_fontface = "plain", border = T, base_line_size = .5, axis_text_angle = 45) +
  theme(axis.ticks = element_line(size = .5),
        legend.position = "none")

```


## Somatic hypermutation (SHM) comparisons

### SHM of all sequences (Fig. S4K)

Here, the SHM for all antigen-specific sequences is combined by group. The two groups were compared against each other at each of two time points for three different specificities: Total F, preF, or preF/postF (DP). For this comparison, a normal distribution can be assumed due to the large number of sequences. Thus, a two-tailed Student’s t-test was employed. This means a total of six (6) comparisons were made. To correct for these multiple comparisons, the false discovery rate correction by Benjamini & Hochberg (1995) was applied (alpha = 0.05). Also, the p-values and adjusted p-values for each comparison are listed in the table that follows. Due to the very large sample size, small differences can lead to extremely small p-values. Therefore, we have also calculated the Cohen’s d (1988) to estimate the effect size between the two group means. The magnitude of the effect size was small for most comparisons, suggesting that these highly statistically significant but small differences may not have biological significance.

```{r SHM_group}
rds_indiv_total <- rds_merge %>%
  mutate(specificity_group = "Total") 

rds_indiv_plot <- rbind(rds_merge, rds_indiv_total)

rds_indiv_plot <- rds_indiv_plot %>%
  filter(specificity_group != "PostF") %>%
  mutate(Group_specificity = paste(specificity_group, Timepoint, Group, sep = "_")) %>%
  mutate(Group_specificity = factor(Group_specificity, levels = c("Total_B1_20-mer", "Total_B1_1-mer", "Total_B2_20-mer", "Total_B2_1-mer", "PreF_B1_20-mer", "PreF_B1_1-mer", "PreF_B2_20-mer", "PreF_B2_1-mer", "DP_B1_20-mer", "DP_B1_1-mer", "DP_B2_20-mer", "DP_B2_1-mer"))) %>% ungroup() %>% drop_na(Group_specificity)

# Save the dataset from above used for statistics
write.csv(rds_indiv_plot %>% select(ID, Timepoint, Group_specificity, V_errors), 
          paste0("../", result.dir, "antigen_specific_total_shm.csv"),row.names = FALSE)


# The two-tailed Student's t-test with an FDR correction is run for the 6 comparisons specified earlier
stat.test <- rds_indiv_plot %>%
              t_test(formula = V_errors ~ Group_specificity, 
                          comparisons = my_comparisons, 
                          p.adjust.method = "fdr", 
                          paired = FALSE) %>%
  add_xy_position() %>%
  mutate(p.adj = ifelse(p.adj<= 0.00001, "0.0000",p.adj))

# The effect size was calculated using Cohen's method
stat.effectsize <- rds_indiv_plot %>%
              cohens_d(formula = V_errors ~ Group_specificity, 
                          comparisons = my_comparisons,
                          paired = FALSE)
# Staltistical results are merged in a single object
stats <- left_join(stat.test, stat.effectsize, by = c("group1","group2", ".y.", "n1", "n2")) %>%
  mutate(effsize = paste0("d=",round(effsize, 2)))

# The statistical analyses, including effect size, are printed as a table (shown below)
stats %>%
  select(-c(.y., y.position,	groups,	xmin,	xmax)) %>%
  kable %>%
  kable_styling("striped") %>% 
 scroll_box(height = "200px")

# The SHM mean, standard deviation, n size, and the confidence interval per group was calculated and saved to summarise the dataset used and provided within this repository
counts <- rds_indiv_plot %>% group_by(Group, specificity_group) %>%
  rename(shm = V_errors) %>%
  summarise(mean.shm = mean(shm, na.rm = TRUE),
            sd.shm = sd(shm, na.rm = TRUE),
            n.shm = n()) %>%
  mutate(se.shm = sd.shm / sqrt(n.shm),
         lower.ci.shm = mean.shm - qt(1 - (0.05 / 2), n.shm - 1) * se.shm,
         upper.ci.shm = mean.shm + qt(1 - (0.05 / 2), n.shm - 1) * se.shm)

write.csv(counts, 
          paste0("../", result.dir, "antigen_specific_total_shm_stats.csv"),row.names = FALSE)

# The data is plotted as a dot plot with corresponding adjusted p-values and Cohen's d effect size
rds_indiv_plot %>%
  ggpubr::ggviolin(x = "Group_specificity", y = "V_errors", fill = "Group_specificity", group = "Group_specificity", 
                    legend = "none") +
  geom_boxplot(outlier.shape = NA, width = 0.15, color = "black", alpha = 0.2)+
  geom_vline(xintercept = c(4.5, 8.5), linetype = "dotted") +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 80)) +
  scale_shape_manual(values=NA)+
  scale_x_discrete(expand = c(0, 0)) +
  scale_fill_manual(values = rep(c("#5F90B0", "#D896C1"), 6)) +
  labs(y = "# IGHV nucleotide mutations",  x= "") +
  stat_pvalue_manual(stats, label = "p.adj", y.position = 70) +
  stat_pvalue_manual(stats, label = "effsize", y.position = 60, remove.bracket = TRUE) +
  ggprism::theme_prism(base_fontface = "plain", border = T, base_line_size = .5, axis_text_angle = 45) +
  theme(axis.ticks = element_line(size = .5),
        legend.position = "none") 

```

### Mean SHM per animal (Fig. S4K)

Here the SHM data is summarized per animal, so each dot represents the average SHM of all the antigen-specific sequences for each animal. As before, the two groups were compared against each other at each of two time points for three different specificities: Total F, preF, or preF/postF (DP). For this, a two-tailed Wilcoxon rank sum test (a.k.a. Mann-Whitney U test) was employed. This means a total of six (6) comparisons were made. To correct for these multiple comparisons, the false discovery rate correction by Benjamini & Hochberg (1995) was applied (alpha = 0.05). Also, the p-values and adjusted p-values for each comparison are listed in the table that follows.

```{r shm_per_animal}
# The SHM arithmetic mean was calculated per animal and is provided within this repository
rds_indiv_plot_summ <- rds_indiv_plot %>%
  filter(Group_specificity != "PostF") %>%
  group_by(ID, Group_specificity) %>%
  summarise(avg_V_errors = mean(V_errors, na.rm = TRUE)) %>%
  ungroup() %>%
  tidyr::drop_na()

write.csv(rds_indiv_plot_summ, 
          paste0("../", result.dir, "antigen_specific_mean_shm_per_animal.csv"),row.names = FALSE)

# The two-tailed Wilcoxon rank sum test with an FDR correction is run for the 6 comparisons specified earlier
stat.test <- rds_indiv_plot_summ %>%
              wilcox_test(formula = avg_V_errors ~ Group_specificity, 
                          comparisons = my_comparisons, 
                          p.adjust.method = "fdr", 
                          paired = FALSE) %>%
  add_xy_position()

# The statistical analyses are printed as a table (shown below)
stat.test %>%
  select(-c(.y., y.position,	groups,	xmin,	xmax)) %>%
  kable %>%
  kable_styling("striped") %>% 
 scroll_box(height = "200px")

# The data is plotted as a dot plot with corresponding adjusted p-values
rds_indiv_plot_summ %>%
  ggpubr::ggdotplot(x = "Group_specificity", y = "avg_V_errors", fill = "Group_specificity", group = "Group_specificity", 
                    legend = "none") +
  geom_vline(xintercept = c(4.5, 8.5), linetype = "dotted") +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 25)) +
  scale_shape_manual(values=NA)+
  scale_x_discrete(expand = c(0, 0)) +
  scale_fill_manual(values = rep(c("#5F90B0", "#D896C1"), 6)) +
  stat_summary(fun.y = mean, 
               geom = "crossbar") +
  labs(y = "# IGHV nucleotide mutations",  x= "") +
  stat_pvalue_manual(stat.test, label = "p.adj", y.position = 22) +
  ggprism::theme_prism(base_fontface = "plain", border = T, base_line_size = .5, axis_text_angle = 45) +
  theme(axis.ticks = element_line(size = .5),
        legend.position = "none") 


```

# SessionInfo

```{r sessioninfo}
sessionInfo()
```
